package com.kh.chap02_abstract.part02.model.vo;

		//예약어
public interface Basic {

	/*
	 * 인터페이스
	 * 	- 상수필드와 추상 메서드만 사용 가능한 추상클래스의 변형체(jdk7 이전)
	 * 	- 인터페이스에서 필드는 무조건 상수필드이며, 메서드는 무조건 "추상메서드" 이다.
	 * 	- 특정 클래스에서 무조건 구현해야하는 기능이 존재하는 경우 인터페이스를 만들어 상속시킨다.
	 * 	- 인터페이스는 다중상속을 허용한다.
	 * 	  ( 인터페이스들은 결국 메서드의 이름, 반환형, 매개변수만 정의하고 있으므로 
	 * 		최종 구현 부분은 인터페이스를 상속받음 클래스에서 딱 한번만 이루어지므로 다중상속이 가능 )
	 * 	- 추상클래스와 다르게 강한 규칙성으로 통일된 인터페이스를 갖추게 할 때 사용
	 * 
	 * 추상클래스와 인터페이스
	 * 	1. 공통점
	 * 		- 객체 생성은 안되나, 참조변수로서 사용가능 (업캐스팅)
	 * 		- 인터페이스 및 추상클래스를 상속받는 클래스에서는 추상매서드를 강제로 구현해야한다.
	 * 	2. 차이점
	 * 		- 추상클래스에서는 인스턴스 변수(필드) 및 일반 배서드를 생성 할 수 있지만, 인터페이스는
	 * 		  오직 상수필드와 추상메서드만 사용가능하다.
	 * 		- 사용하는 목적이 다르다
	 * 
	 * 	추상클래스는 클래스들이 가지는 공통속성과, 기능을 자식클래스에게 상속시키면서 특정 기능 구현을
	 * 	강제하고자 할때 사용하기 때문에 "상속"이 주 목적이고, "강제 기능구현"은 부가적인 목적이다.
	 * 	
	 * 	인터페이스는 클래스의 기능 구현을 "약속"하기위해 사용한다. 인터페이스를 구현한 모든 클래스는 
	 * 	"동일한 동작"을 보장 할 수 있다. 일관된 동작을 보장하기 위해 사용한다.
	 * 
	 * 	인터페이스의 상송( implements )
	 * 	 - 클래스와 클래스의 상속관계 : 클래스명 extends 부모 클래스
	 * 	 - 클래스와 인터페이스의 상속관계 : 클래스명 implements 인터페이스명 [,인터페이스, 인터페이스]
	 * 	 - 인터페이스와 인터페이스의 상속관계 : 인터페이스명 extends 인터페이스명 [, 인터페이스명]
	 * 
	 * */
	
	
	// 인터페이스 내부에서는 상수필드(public static final)만 정의가능
	// 따라서 , 상수필드예약어를 생략해도 항상 자동으로 추가되어 있다.
	/*public static final */int num = 10;	//기울어짐 : static 변수
	//int num;	// 사용불가
	
	
	//인터페이스 내부에서는 추상메서드만 정의할 수 있다.
	//기본 메서드는 항상 추상메서드로 간주하기 때문에 public abstract 생략가능
	/*public abstract*/ void eat();
	//public void eat() {}	//불가
	
	
	//jdk8버전 이후
	//인터페이스 내부에서 디폴트 매서드를 사용 할 수 있다.
	//인터페이스 구현하는 모든 하위클래스에서 공통된 기능이 존재하는 경우 사용
	default void breathing() {
		System.out.println("숨쉬기");
	}
	
	//정적메서드는 사용가능	//class.method
	//상수필드와 동일하게 "객체생성 없이" 접근 가능한 매서드이므로 인터페이스에서도 작성 할 수 있다.
	static void thinking() {
		System.out.println("생각하기");
	}
	
	
	

}
